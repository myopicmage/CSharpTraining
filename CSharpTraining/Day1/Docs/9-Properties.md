# Lesson 8 - Properties

You will occasionally hear the terms "field" and "property" used interchangeably. They're very similar, but not exactly the same. Properties do a lot of work for you.

## Fields

When classes need to store internal state/data, they'll use class members in the form of fields or properties. Fields are the simpler of the two. They're no frills, simple pieces of data on a class. Anything in the class can modify the field.

```csharp
class MyClass
{
  // this is a field. it ends with a ;
  public string MyField;

  private IPersonService _personSvc = Container.WorkScope.Resolve<IPersonService>();
}
```

## Properties

Properties are enhanced fields. They follow the OO principle of encapsulation in that there's no direct access to a property. Everything goes through a getter or a setter, though invisibly. 

```csharp
class MyClass
{
  // this becomes a property when you add the { get; set; }
  public string MyProperty { get; set; }

  // if you'd like some immutability, you can mark set as private
  // only members of this class can set ExternallyImmutable
  public string ExternallyImmutable { get; private set; }

  // if you'd like true immutability, you can leave set off entirely
  // Immutable can only be set in the constructor
  public string Immutable { get; }

  // Properties can also have default values
  public string Greeting { get; set; } = "Hello, my name is Inigo Montoya";

  // You can set a default on an immutable property
  public string ImmutableGreeting { get; } = "Hello, my name is Inigo Montoya";
}
```

The `{ get; set; }` syntax is what's called an auto-property. It automatically generates a basic getter and setter method for the property, using an invisible, compiler-generated backing field. It is roughly equivalent to this code

```csharp
class MyClass
{
  private string _myProperty;
  public string GetMyProperty() => _myProperty;
  public void SetMyProperty(string value) 
  {
    _myProperty = value;
  }
}
```

In the early versions of C#, there we no auto properties, so you may occasionally see code like this

```csharp
private string _myProperty;
public string MyProperty
{
  get 
  {
    return _myProperty;
  }
  set
  {
    _myProperty = value;
  }
}
```

This is what the `{ get; set; }` syntax does by default.

The `get` and `set` methods generated by the compiler are actually modifiable, allowing for more complicated logic.

```csharp
private IPersonService _svc;

public IPersonService PersonService 
{
  get
  {
    if (_svc is null)
    {
      _svc = GetPersonService();
    }

    return _svc;
  }
  set // set automatically takes in a parameter called value which is the type of the property
  {
    _svc = value;
  }
}
```

Modified `get` and `set` methods are commonly used for what's called computed properties. 

```csharp
public string FirstName { get; set; }
public string LastName { get; set; }
public string FullName 
{
  get
  {
    return $"{FirstName} {LastName}";
  }
}

// you can also use => syntax for get-only computed properties
public string FullName => $"{FirstName} {LastName}";

// conceptually, it's the same thing as this, but it looks and feels the same
// as every other property. 
public string FullName() => $"{FirstName} {LastName}";

// you'd access FullName the same as any other property
Console.WriteLine($"The first name is: {FirstName}");
Console.WriteLine($"The full name is: {FullName}"); // notice no ()
```

# Exercise

1. Create a `Developer` class to represent... a developer.
2. Give it a few properties that make sense to you.
3. Create a method called `WorkDay()` and any helper methods you'd like. It should print
    1. The name of the developer
    2. Where they work
    3. What they do in the morning
    4. What they do at lunch
    5. What they do in the afternoon
    6. What they do at the end of the day

[Next Lesson](10-Constructors.md)